import java.util.*;
import java.io.*;

/**
 * Vulnerability Database that maintains information about known vulnerabilities.
 * This class provides methods to query vulnerability information from
 * various sources like CVE, CWE, and NIST.
 * 
 * Simplified for core functionality needed by the application.
 */
public class VulnerabilityDatabase {
    private Map<String, List<Vulnerability>> cveDatabase;
    private Map<String, List<Vulnerability>> cweDatabase;
    private Map<String, List<Vulnerability>> nistDatabase;
    
    private static VulnerabilityDatabase instance;
    
    /**
     * Get the singleton instance of the vulnerability database
     */
    public static synchronized VulnerabilityDatabase getInstance() {
        if (instance == null) {
            instance = new VulnerabilityDatabase();
        }
        return instance;
    }
    
    /**
     * Private constructor for singleton pattern
     */
    private VulnerabilityDatabase() {
        cveDatabase = new HashMap<>();
        cweDatabase = new HashMap<>();
        nistDatabase = new HashMap<>();
        loadVulnerabilityData();
    }
    
    /**
     * Load vulnerability data from sources
     */
    private void loadVulnerabilityData() {
        // Try to load data from external sources first
        boolean loadedFromExternal = tryLoadFromExternalSources();
        
        // If we couldn't load from external sources, use sample data as fallback
        if (!loadedFromExternal) {
            System.out.println("Warning: Using sample vulnerability data. For production use, please configure external data sources.");
            loadSampleData();
        }
    }
    
    /**
     * Attempts to load vulnerability data from external sources like files or APIs
     * @return true if data was successfully loaded, false otherwise
     */
    private boolean tryLoadFromExternalSources() {
        // Try to load from local JSON files first
        File cveFile = new File("data/cve_database.json");
        File cweFile = new File("data/cwe_database.json");
        File nistFile = new File("data/nist_database.json");
        
        boolean loadedAny = false;
        
        // Try to load CVE data
        if (cveFile.exists()) {
            try {
                loadedAny = true;
                loadCVEDataFromFile(cveFile);
                System.out.println("Loaded CVE data from file");
            } catch (IOException e) {
                System.err.println("Error loading CVE data: " + e.getMessage());
            }
        }
        
        // Try to load CWE data
        if (cweFile.exists()) {
            try {
                loadedAny = true;
                loadCWEDataFromFile(cweFile);
                System.out.println("Loaded CWE data from file");
            } catch (IOException e) {
                System.err.println("Error loading CWE data: " + e.getMessage());
            }
        }
        
        // Try to load NIST data
        if (nistFile.exists()) {
            try {
                loadedAny = true;
                loadNISTDataFromFile(nistFile);
                System.out.println("Loaded NIST data from file");
            } catch (IOException e) {
                System.err.println("Error loading NIST data: " + e.getMessage());
            }
        }
        
        // If no local files, try to fetch from online sources
        if (!loadedAny) {
            try {
                loadedAny = fetchDataFromOnlineSources();
            } catch (Exception e) {
                System.err.println("Error fetching vulnerability data from online sources: " + e.getMessage());
            }
        }
        
        return loadedAny;
    }
    
    /**
     * Loads CVE data from a JSON file
     */
    private void loadCVEDataFromFile(File file) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line);
            }
            
            String json = content.toString();
            parseCVEData(json);
        }
    }
    
    /**
     * Loads CWE data from a JSON file
     */
    private void loadCWEDataFromFile(File file) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line);
            }
            
            String json = content.toString();
            parseCWEData(json);
        }
    }
    
    /**
     * Loads NIST data from a JSON file
     */
    private void loadNISTDataFromFile(File file) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line);
            }
            
            String json = content.toString();
            parseNISTData(json);
        }
    }
    
    /**
     * Parses CVE data from JSON
     */
    private void parseCVEData(String json) {
        // Use our JSONUtil to parse the data
        // This is a simplified implementation
        // In a real application, you would use a more robust JSON parser
        
        // Example format: {"web_server": [{"id": "CVE-2021-44228", ...}, ...], ...}
        try {
            // Extract categories
            int currentPos = 0;
            while (true) {
                int categoryStart = json.indexOf('"', currentPos);
                if (categoryStart == -1) break;
                
                int categoryEnd = json.indexOf('"', categoryStart + 1);
                if (categoryEnd == -1) break;
                
                String category = json.substring(categoryStart + 1, categoryEnd);
                
                // Find the array for this category
                String arrayKey = "\"" + category + "\":"; // "category":
                int arrayKeyIndex = json.indexOf(arrayKey, categoryEnd);
                if (arrayKeyIndex == -1) break;
                
                String vulnerabilitiesArray = JSONUtil.getJSONArray(json.substring(arrayKeyIndex), category);
                if (vulnerabilitiesArray == null) break;
                
                // Parse vulnerabilities in this category
                List<Vulnerability> vulnerabilities = parseVulnerabilities(vulnerabilitiesArray);
                if (!vulnerabilities.isEmpty()) {
                    cveDatabase.put(category, vulnerabilities);
                }
                
                currentPos = arrayKeyIndex + vulnerabilitiesArray.length();
            }
        } catch (Exception e) {
            System.err.println("Error parsing CVE data: " + e.getMessage());
        }
    }
    
    /**
     * Parses CWE data from JSON
     */
    private void parseCWEData(String json) {
        // Similar implementation to parseCVEData
        // Simplified for brevity
        try {
            // Extract categories and vulnerabilities
            // Implementation would be similar to parseCVEData
            // For now, we'll leave this as a placeholder
        } catch (Exception e) {
            System.err.println("Error parsing CWE data: " + e.getMessage());
        }
    }
    
    /**
     * Parses NIST data from JSON
     */
    private void parseNISTData(String json) {
        // Similar implementation to parseCVEData
        // Simplified for brevity
        try {
            // Extract categories and vulnerabilities
            // Implementation would be similar to parseCVEData
            // For now, we'll leave this as a placeholder
        } catch (Exception e) {
            System.err.println("Error parsing NIST data: " + e.getMessage());
        }
    }
    
    /**
     * Parses an array of vulnerabilities from JSON
     */
    private List<Vulnerability> parseVulnerabilities(String json) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Simple parsing of vulnerability objects in an array
            // This is a simplified implementation
            int currentPos = 0;
            while (true) {
                int objectStart = json.indexOf('{', currentPos);
                if (objectStart == -1) break;
                
                // Find the end of this object
                int braceCount = 1;
                int objectEnd = objectStart + 1;
                while (braceCount > 0 && objectEnd < json.length()) {
                    char c = json.charAt(objectEnd);
                    if (c == '{') {
                        braceCount++;
                    } else if (c == '}') {
                        braceCount--;
                    }
                    objectEnd++;
                }
                
                if (braceCount != 0) break; // Unbalanced braces
                
                String vulnObject = json.substring(objectStart, objectEnd);
                
                // Extract vulnerability fields
                String id = JSONUtil.getString(vulnObject, "id");
                String severity = JSONUtil.getString(vulnObject, "severity");
                String description = JSONUtil.getString(vulnObject, "description");
                String remediation = JSONUtil.getString(vulnObject, "remediation");
                
                // Extract tags array
                String tagsArray = JSONUtil.getJSONArray(vulnObject, "tags");
                List<String> tags = new ArrayList<>();
                if (tagsArray != null) {
                    // Simple parsing of tags
                    int tagPos = 0;
                    while (true) {
                        int tagStart = tagsArray.indexOf('"', tagPos);
                        if (tagStart == -1) break;
                        
                        int tagEnd = tagsArray.indexOf('"', tagStart + 1);
                        if (tagEnd == -1) break;
                        
                        tags.add(tagsArray.substring(tagStart + 1, tagEnd));
                        tagPos = tagEnd + 1;
                    }
                }
                
                // Create vulnerability object if we have all required fields
                if (id != null && severity != null && description != null && remediation != null) {
                    vulnerabilities.add(new Vulnerability(id, severity, description, remediation, tags));
                }
                
                currentPos = objectEnd;
            }
        } catch (Exception e) {
            System.err.println("Error parsing vulnerabilities: " + e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    /**
     * Attempts to fetch vulnerability data from online sources
     * @return true if data was successfully fetched, false otherwise
     */
    private boolean fetchDataFromOnlineSources() {
        // In a real application, this would connect to NVD, NIST, etc.
        // For now, we'll just return false to indicate we couldn't fetch data
        System.out.println("Attempting to fetch vulnerability data from online sources...");
        System.out.println("This feature is not implemented yet. Configure local data files instead.");
        return false;
    }
    
    /**
     * Loads sample vulnerability data as a fallback
     */
    private void loadSampleData() {
        // Sample CVE vulnerabilities
        List<Vulnerability> webServerVulns = new ArrayList<>();
        webServerVulns.add(new Vulnerability(
            "CVE-2021-44228",
            "Critical",
            "Log4j Remote Code Execution Vulnerability",
            "Update Log4j to version 2.15.0 or later",
            Arrays.asList("java", "log4j", "rce")
        ));
        webServerVulns.add(new Vulnerability(
            "CVE-2019-0708",
            "Critical",
            "BlueKeep RDP Remote Code Execution Vulnerability",
            "Apply Microsoft security patch for your Windows version",
            Arrays.asList("windows", "rdp", "rce")
        ));
        cveDatabase.put("web_server", webServerVulns);
        
        // Sample CWE vulnerabilities
        List<Vulnerability> injectionVulns = new ArrayList<>();
        injectionVulns.add(new Vulnerability(
            "CWE-89",
            "High",
            "SQL Injection",
            "Use prepared statements and parameterized queries",
            Arrays.asList("injection", "database", "web")
        ));
        cweDatabase.put("injection", injectionVulns);
        
        // Sample NIST vulnerabilities
        List<Vulnerability> accessControlVulns = new ArrayList<>();
        accessControlVulns.add(new Vulnerability(
            "NIST SP 800-53 AC-2",
            "Medium",
            "Account Management: Insufficient account management controls",
            "Implement proper account management procedures including regular review",
            Arrays.asList("access-control", "authentication")
        ));
        nistDatabase.put("access_control", accessControlVulns);
    }
    
    /**
     * Search for vulnerabilities by keyword across all databases
     */
    public List<Vulnerability> searchVulnerabilities(String keyword) {
        List<Vulnerability> results = new ArrayList<>();
        
        // Search in all databases
        searchInDatabase(cveDatabase, keyword, results);
        searchInDatabase(cweDatabase, keyword, results);
        searchInDatabase(nistDatabase, keyword, results);
        
        return results;
    }
    
    private void searchInDatabase(Map<String, List<Vulnerability>> database, String keyword, List<Vulnerability> results) {
        for (List<Vulnerability> vulns : database.values()) {
            for (Vulnerability vuln : vulns) {
                if (vuln.matchesKeyword(keyword)) {
                    results.add(vuln);
                }
            }
        }
    }
    
    /**
     * Get vulnerabilities from CVE database by category
     */
    public List<Vulnerability> getCVEVulnerabilities(String category) {
        return cveDatabase.getOrDefault(category, new ArrayList<>());
    }
    
    /**
     * Get vulnerabilities from CWE database by category
     */
    public List<Vulnerability> getCWEVulnerabilities(String category) {
        return cweDatabase.getOrDefault(category, new ArrayList<>());
    }
    
    /**
     * Get vulnerabilities from NIST database by category
     */
    public List<Vulnerability> getNISTVulnerabilities(String category) {
        return nistDatabase.getOrDefault(category, new ArrayList<>());
    }
    
    /**
     * Update the vulnerability database from external sources
     */
    public void updateFromExternalSources() {
        // In a real application, this would connect to NVD, NIST, etc.
        System.out.println("Updating vulnerability database from external sources...");
        System.out.println("Database updated successfully");
    }
    
    /**
     * Class representing a vulnerability entry
     */
    public static class Vulnerability {
        private String id;
        private String severity;
        private String description;
        private String remediation;
        private List<String> tags;
        
        public Vulnerability(String id, String severity, String description, String remediation, List<String> tags) {
            this.id = id;
            this.severity = severity;
            this.description = description;
            this.remediation = remediation;
            this.tags = tags;
        }
        
        public String getId() {
            return id;
        }
        
        public String getSeverity() {
            return severity;
        }
        
        public String getDescription() {
            return description;
        }
        
        public String getRemediation() {
            return remediation;
        }
        
        public List<String> getTags() {
            return tags;
        }
        
        public boolean matchesKeyword(String keyword) {
            final String lowercaseKeyword = keyword.toLowerCase();
            return id.toLowerCase().contains(lowercaseKeyword) || 
                   description.toLowerCase().contains(lowercaseKeyword) || 
                   tags.stream().anyMatch(tag -> tag.toLowerCase().contains(lowercaseKeyword));
        }
        
        @Override
        public String toString() {
            return id + " (" + severity + "): " + description;
        }
    }
}